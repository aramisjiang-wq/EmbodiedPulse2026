# 具身论文页面数据流转完整文档

## 一、数据流转路径总览

```
数据库 (papers.db)
  ↓
Flask API (/api/papers)
  ↓
数据转换 (build_nested_papers)
  ↓
JSON响应
  ↓
前端请求 (fetch /api/papers)
  ↓
数据标准化 (normalizePapersResponse)
  ↓
数据扁平化 (flattenPaperData)
  ↓
标签元数据对齐 (ensureCategoryMetaFromData)
  ↓
渲染论文列表 (renderPapers)
  ↓
DOM更新
```

## 二、详细流转环节

### 1. 数据库层 (Database Layer)

**位置**: `models.py`

**数据结构**:
```python
class Paper:
    id: String (ArXiv ID, 主键)
    title: Text (论文标题)
    authors: Text (作者列表，逗号分隔)
    publish_date: Date (发布日期)
    update_date: Date (更新日期)
    pdf_url: Text (PDF链接)
    code_url: Text (代码链接，可选)
    abstract: Text (摘要，可选)
    category: String (类别标签，如 "Perception/2D Perception")
    citation_count: Integer (被引用数量)
    influential_citation_count: Integer (高影响力引用数)
    author_affiliations: Text (作者机构信息，JSON字符串)
    venue: String (发表期刊/会议)
    publication_year: Integer (发表年份)
    created_at: DateTime (创建时间)
    updated_at: DateTime (更新时间)
```

**查询规则**:
- 所有论文按 `publish_date` 降序排列
- 使用 `created_at` 计算新论文数量（昨天创建的论文）

---

### 2. API层 (API Layer)

**位置**: `app.py` → `@app.route('/api/papers')`

**处理流程**:

#### 2.1 数据查询
```python
# 1. 查询所有论文（按发布日期降序）
papers = session.query(Paper).order_by(Paper.publish_date.desc()).all()

# 2. 获取最后更新时间（数据库中最新的updated_at）
last_update = session.query(func.max(Paper.updated_at)).scalar()

# 3. 计算昨天新创建的论文数量
# 规则：使用created_at字段，计算昨天00:00:00到23:59:59之间创建的论文
yesterday_start = datetime.combine(yesterday, datetime.min.time())
today_start = datetime.combine(today, datetime.min.time())
new_papers_count = session.query(Paper).filter(
    Paper.created_at >= yesterday_start,
    Paper.created_at < today_start
).count()
```

#### 2.2 数据转换
```python
# 使用 build_nested_papers 将论文列表转换为扁平化分类结构
nested = build_nested_papers(papers)
```

**`build_nested_papers` 函数逻辑**:
```python
def build_nested_papers(papers):
    """将论文列表组织为扁平化分类结构"""
    flat = {}
    for paper in papers:
        # 1. 规范化类别标签
        norm_cat = normalize_category(paper.category)
        
        # 2. 转换为字典
        paper_dict = paper.to_dict()
        paper_dict['category'] = norm_cat  # 使用规范化后的标签
        
        # 3. 按类别分组
        flat.setdefault(norm_cat, []).append(paper_dict)
    return flat
```

**输出结构**:
```json
{
  "Perception/2D Perception": [
    {
      "id": "2512.12345",
      "title": "论文标题",
      "authors": "作者1, 作者2",
      "publish_date": "2025-12-16",
      "pdf_url": "https://arxiv.org/pdf/...",
      "code_url": "https://github.com/...",
      "abstract": "摘要内容",
      "category": "Perception/2D Perception",
      ...
    },
    ...
  ],
  "Perception/3D Perception": [...],
  ...
}
```

#### 2.3 API响应
```json
{
  "success": true,
  "data": {
    "Perception/2D Perception": [...],
    "Perception/3D Perception": [...],
    ...
  },
  "last_update": "2025-12-17 11:48:37",
  "total_count": 14376,
  "new_papers_count": 1089
}
```

**失败回退机制**:
- 如果数据库查询失败，回退到JSON文件 (`docs/cv-arxiv-daily.json`)
- 如果JSON文件也失败，返回错误响应

---

### 3. 前端请求层 (Frontend Request Layer)

**位置**: `static/js/app.js` → `loadPapers()`

**请求流程**:
```javascript
async function loadPapers(showNewBadge = true) {
    // 1. 显示加载状态
    container.innerHTML = '<div class="loading-spinner">...</div>';
    
    // 2. 发送API请求
    const response = await fetch('/api/papers');
    const result = await response.json();
    
    // 3. 数据标准化
    papersDataNested = normalizePapersResponse(result.data);
    
    // 4. 数据扁平化
    papersData = flattenPaperData(papersDataNested);
    
    // 5. 确保标签元数据
    ensureCategoryMetaFromData(papersData);
    
    // 6. 渲染论文
    renderPapers(papersDataNested);
    
    // 7. 更新新论文红点
    if (showNewBadge) {
        updateNewPapersBadge(result.new_papers_count);
    }
}
```

---

### 4. 数据标准化层 (Data Normalization Layer)

**位置**: `static/js/app.js` → `normalizePapersResponse()`

**功能**: 将API返回的数据标准化为统一格式

**输入格式** (可能的情况):
1. 扁平结构: `{ "category": [papers] }`
2. 嵌套结构: `{ "level1": { "level2": { "leaf": [papers] } } }`
3. 数组: `[paper1, paper2, ...]`
4. 单个论文对象

**输出格式** (统一):
```javascript
{
  "All": {
    "All": {
      "Perception/2D Perception": [papers],
      "Perception/3D Perception": [papers],
      ...
    }
  }
}
```

**处理逻辑**:
```javascript
function normalizePapersResponse(raw) {
    // 1. 如果是数组，按category分组
    if (Array.isArray(raw)) {
        const buckets = {};
        raw.forEach(paper => {
            const leaf = paper.category || 'Uncategorized';
            buckets[leaf] = buckets[leaf] || [];
            buckets[leaf].push(paper);
        });
        return { All: { All: buckets } };
    }
    
    // 2. 如果是扁平结构 (leaf -> [papers])
    const values = Object.values(raw);
    const isFlat = values.every(v => Array.isArray(v));
    if (isFlat) {
        return { All: { All: raw } };
    }
    
    // 3. 默认假设已经是嵌套结构
    return raw;
}
```

---

### 5. 数据扁平化层 (Data Flattening Layer)

**位置**: `static/js/app.js` → `flattenPaperData()`

**功能**: 将嵌套结构扁平化为 `{ category: [papers] }` 格式，便于统计和渲染

**输入**: 嵌套结构
```javascript
{
  "All": {
    "All": {
      "Perception/2D Perception": [papers],
      "Perception/3D Perception": [papers]
    }
  }
}
```

**输出**: 扁平结构
```javascript
{
  "Perception/2D Perception": [papers],
  "Perception/3D Perception": [papers],
  ...
}
```

**处理逻辑**:
```javascript
function flattenPaperData(nested) {
    const flat = {};
    
    // 1. 如果已经是扁平结构，直接返回
    const values = Object.values(nested);
    const isFlat = values.every(v => Array.isArray(v));
    if (isFlat) {
        return nested;
    }
    
    // 2. 递归处理嵌套结构
    Object.entries(nested).forEach(([l1, subDict]) => {
        if (Array.isArray(subDict)) {
            // 直接是论文列表
            subDict.forEach(paper => {
                const leaf = paper.category || 'Uncategorized';
                flat[leaf] = flat[leaf] || [];
                flat[leaf].push(paper);
            });
        } else {
            // 继续递归处理
            Object.entries(subDict).forEach(([l2, leaves]) => {
                Object.entries(leaves).forEach(([leafKey, papers]) => {
                    if (Array.isArray(papers)) {
                        flat[leafKey] = papers;
                    }
                });
            });
        }
    });
    
    return flat;
}
```

---

### 6. 标签元数据对齐层 (Category Metadata Alignment)

**位置**: `static/js/app.js` → `ensureCategoryMetaFromData()`

**功能**: 确保标签元数据（显示名、顺序）与数据对齐

**标签元数据结构**:
```javascript
let CATEGORY_META = {
    order: ['Perception/2D Perception', 'Perception/3D Perception', ...],
    display: {
        'Perception/2D Perception': '2D感知',
        'Perception/3D Perception': '3D感知',
        ...
    },
    tree: [...] // 三层标签树结构
};
```

**处理逻辑**:
```javascript
function ensureCategoryMetaFromData(data) {
    // 1. 如果已有树结构，从树中提取order和display
    if (CATEGORY_META.tree && CATEGORY_META.tree.length > 0) {
        CATEGORY_META.order = [];
        CATEGORY_META.tree.forEach(layer => {
            layer.children.forEach(sub => {
                sub.leaves.forEach(([leafKey, leafDisplay]) => {
                    CATEGORY_META.order.push(leafKey);
                    CATEGORY_META.display[leafKey] = leafDisplay || leafKey;
                });
            });
        });
        return;
    }
    
    // 2. 如果没有树，用数据键作为兜底
    if (!CATEGORY_META.order || CATEGORY_META.order.length === 0) {
        CATEGORY_META.order = Object.keys(data || {}).sort();
    }
    
    // 3. 确保每个键都有显示名
    CATEGORY_META.order.forEach(key => {
        if (!CATEGORY_META.display[key]) {
            CATEGORY_META.display[key] = key;
        }
    });
}
```

---

### 7. 标签规范化层 (Category Normalization)

**位置**: `taxonomy.py` → `normalize_category()`

**功能**: 将数据库中的类别标签规范化为标准格式

**规则**:
1. 如果标签在 `NEW_TAXONOMY` 中，返回标准键（如 `"Perception/2D Perception"`）
2. 如果标签不在 `NEW_TAXONOMY` 中，尝试通过 `get_category_from_tag()` 匹配
3. 如果都匹配不上，返回 `"Uncategorized"`

**处理逻辑**:
```python
def normalize_category(category: str) -> str:
    if not category:
        return UNCATEGORIZED_KEY
    
    # 1. 直接匹配
    if category in NEW_TAXONOMY:
        return category
    
    # 2. 尝试通过标签匹配
    matched = get_category_from_tag(category)
    if matched != UNCATEGORIZED_KEY:
        return matched
    
    # 3. 返回未分类
    return UNCATEGORIZED_KEY
```

---

### 8. 渲染层 (Rendering Layer)

**位置**: `static/js/app.js` → `renderPapers()`

**功能**: 将数据渲染为HTML

**处理流程**:

#### 8.1 数据准备
```javascript
function renderPapers(data) {
    // 1. 扁平化数据用于统计
    const flatData = flattenPaperData(data);
    const keywords = Object.keys(flatData);
    
    // 2. 计算总数
    let totalCount = 0;
    Object.values(flatData).forEach(categoryPapers => {
        if (Array.isArray(categoryPapers)) {
            totalCount += categoryPapers.length;
        }
    });
}
```

#### 8.2 创建标签页
```javascript
// 1. 创建"全量"标签（默认选中）
const allTab = document.createElement('button');
allTab.className = 'tab tab-all active';
allTab.textContent = `全部 (${totalCount})`;
allTab.onclick = () => switchTab('all');

// 2. 为每个类别创建标签
keywords.forEach(keyword => {
    const tab = document.createElement('button');
    tab.className = 'tab';
    tab.textContent = `${CATEGORY_META.display[keyword] || keyword} (${flatData[keyword].length})`;
    tab.onclick = () => switchTab(keyword);
    
    // 添加新论文红点（如果有）
    if (newPapersCount > 0) {
        // 创建红点元素
    }
});
```

#### 8.3 渲染论文列表
```javascript
// 根据当前选中的标签渲染论文
function renderPaperList(category) {
    const papers = category === 'all' 
        ? getAllPapers(flatData)
        : flatData[category] || [];
    
    papers.forEach(paper => {
        const paperElement = createPaperElement(paper);
        container.appendChild(paperElement);
    });
}
```

**论文元素结构**:
```html
<div class="paper-item">
    <div class="paper-header">
        <h3 class="paper-title">
            <a href="${paper.pdf_url}" target="_blank">${paper.title}</a>
        </h3>
        <div class="paper-meta">
            <span class="paper-date">${paper.publish_date}</span>
            <span class="paper-authors">${paper.authors}</span>
        </div>
    </div>
    <div class="paper-abstract">${paper.abstract}</div>
    <div class="paper-links">
        <a href="${paper.pdf_url}" target="_blank">PDF</a>
        ${paper.code_url ? `<a href="${paper.code_url}" target="_blank">Code</a>` : ''}
    </div>
</div>
```

---

## 三、关键规则和约束

### 1. 类别标签规则

**标签格式**: `"Level1/Level2/Leaf"` 或 `"Level1/Leaf"`

**示例**:
- `"Perception/2D Perception"` (Level1/Leaf)
- `"Decision/Task Planning"` (Level1/Leaf)
- `"Motion/Locomotion/Walking"` (Level1/Level2/Leaf)

**规范化规则**:
1. 数据库中的 `category` 字段可能不标准
2. 通过 `normalize_category()` 规范化为标准格式
3. 如果无法匹配，归类为 `"Uncategorized"`

### 2. 新论文计算规则

**规则**: 今天看昨天的新论文

**计算逻辑**:
```python
today = date.today()
yesterday = today - timedelta(days=1)
yesterday_start = datetime.combine(yesterday, datetime.min.time())  # 昨天 00:00:00
today_start = datetime.combine(today, datetime.min.time())  # 今天 00:00:00

new_papers_count = session.query(Paper).filter(
    Paper.created_at >= yesterday_start,
    Paper.created_at < today_start
).count()
```

**说明**:
- 使用 `created_at` 字段（论文被添加到数据库的时间）
- 不是使用 `publish_date`（论文的发布日期）
- 计算的是昨天创建的论文数量

### 3. 数据排序规则

**后端排序**:
- 论文按 `publish_date` 降序排列（最新的在前）

**前端排序**:
- 标签页按 `CATEGORY_META.order` 顺序显示
- 论文列表保持后端排序（按发布日期降序）

### 4. 数据去重规则

**后端去重**:
- 基于论文ID（ArXiv ID）去重
- 基于标题相似度去重（阈值0.85）

**前端去重**:
- 无额外去重逻辑（依赖后端）

### 5. 错误处理规则

**API错误处理**:
1. 数据库查询失败 → 回退到JSON文件
2. JSON文件也失败 → 返回错误响应

**前端错误处理**:
1. API请求失败 → 显示错误消息
2. 数据格式错误 → 显示错误消息
3. 渲染失败 → 显示空状态

---

## 四、数据格式规范

### 1. API响应格式

```json
{
  "success": true,
  "data": {
    "Perception/2D Perception": [
      {
        "id": "2512.12345",
        "title": "论文标题",
        "authors": "作者1, 作者2",
        "publish_date": "2025-12-16",
        "update_date": null,
        "pdf_url": "https://arxiv.org/pdf/2512.12345",
        "code_url": "https://github.com/...",
        "abstract": "摘要内容",
        "category": "Perception/2D Perception",
        "citation_count": 0,
        "influential_citation_count": 0,
        "author_affiliations": null,
        "venue": null,
        "publication_year": null,
        "created_at": "2025-12-16T15:55:15",
        "updated_at": "2025-12-16T15:55:15"
      }
    ],
    "Perception/3D Perception": [...]
  },
  "last_update": "2025-12-17 11:48:37",
  "total_count": 14376,
  "new_papers_count": 1089
}
```

### 2. 前端数据格式

**扁平化后**:
```javascript
{
  "Perception/2D Perception": [paper1, paper2, ...],
  "Perception/3D Perception": [paper3, paper4, ...],
  ...
}
```

**嵌套结构** (用于渲染):
```javascript
{
  "All": {
    "All": {
      "Perception/2D Perception": [papers],
      "Perception/3D Perception": [papers],
      ...
    }
  }
}
```

---

## 五、关键函数说明

### 后端函数

1. **`build_nested_papers(papers)`**
   - 输入: 论文对象列表
   - 输出: 扁平化分类字典 `{ category: [papers] }`
   - 功能: 按类别分组论文

2. **`normalize_category(category)`**
   - 输入: 类别字符串
   - 输出: 规范化后的类别字符串
   - 功能: 将类别标签规范化为标准格式

### 前端函数

1. **`normalizePapersResponse(raw)`**
   - 输入: API返回的原始数据（多种格式）
   - 输出: 统一的嵌套结构
   - 功能: 标准化数据格式

2. **`flattenPaperData(nested)`**
   - 输入: 嵌套结构
   - 输出: 扁平结构 `{ category: [papers] }`
   - 功能: 扁平化数据便于统计和渲染

3. **`renderPapers(data)`**
   - 输入: 嵌套结构数据
   - 输出: 无（直接更新DOM）
   - 功能: 渲染论文列表和标签页

---

## 六、数据流转时序图

```
1. 用户访问页面
   ↓
2. 前端调用 loadPapers()
   ↓
3. 发送 GET /api/papers 请求
   ↓
4. 后端查询数据库
   ↓
5. 后端调用 build_nested_papers()
   ↓
6. 后端返回JSON响应
   ↓
7. 前端接收响应
   ↓
8. 前端调用 normalizePapersResponse()
   ↓
9. 前端调用 flattenPaperData()
   ↓
10. 前端调用 ensureCategoryMetaFromData()
   ↓
11. 前端调用 renderPapers()
   ↓
12. DOM更新，页面显示
```

---

## 七、常见问题和排查

### 1. 论文不显示

**可能原因**:
- 类别标签未规范化
- 数据格式不正确
- 渲染函数出错

**排查步骤**:
1. 检查浏览器控制台错误
2. 检查API响应格式
3. 检查类别标签是否在 `CATEGORY_META.order` 中

### 2. 新论文数量不正确

**可能原因**:
- `created_at` 字段不正确
- 时区问题
- 日期计算逻辑错误

**排查步骤**:
1. 检查数据库中 `created_at` 字段
2. 检查日期计算逻辑
3. 检查时区设置

### 3. 类别标签显示不正确

**可能原因**:
- 标签未规范化
- `CATEGORY_META.display` 中缺少显示名
- 标签不在 `NEW_TAXONOMY` 中

**排查步骤**:
1. 检查 `normalize_category()` 函数
2. 检查 `CATEGORY_META.display` 配置
3. 检查 `taxonomy.py` 中的标签定义

---

## 八、相关文件清单

### 后端文件
- `app.py` - Flask应用，API路由
- `models.py` - 数据库模型定义
- `taxonomy.py` - 标签体系定义和工具函数
- `database.py` - 数据库连接和初始化

### 前端文件
- `static/js/app.js` - 前端JavaScript逻辑
- `templates/index.html` - 论文页面HTML模板
- `static/css/` - 样式文件

### 配置文件
- `config.yaml` - 抓取配置（关键词等）
- `.env` - 环境变量配置

---

## 九、总结

具身论文页面的数据流转是一个完整的**数据库 → API → 前端**流程，包含：

1. **数据查询**: 从数据库按发布日期降序查询所有论文
2. **数据转换**: 将论文列表按类别分组
3. **数据标准化**: 前端标准化数据格式
4. **数据扁平化**: 扁平化数据便于统计和渲染
5. **标签对齐**: 确保标签元数据与数据对齐
6. **渲染显示**: 渲染论文列表和标签页

关键规则：
- 使用 `created_at` 计算新论文数量（今天看昨天的）
- 使用 `publish_date` 排序论文（最新的在前）
- 类别标签需要规范化处理
- 支持多种数据格式的自动转换

