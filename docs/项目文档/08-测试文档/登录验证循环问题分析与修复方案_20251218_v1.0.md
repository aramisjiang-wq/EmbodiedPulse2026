# 登录验证循环问题分析与修复方案

## 问题描述

在 `https://essay.gradmotion.com/login` 登录后，点击论文清单去其他页面，马上又跳回到登录页面，反反复复。

## 问题分析

### 登录流程

1. 用户在 `essay.gradmotion.com/login` 点击飞书登录
2. 跳转到飞书授权页面
3. 授权后回调到 `/api/auth/feishu/callback`（在 `login.gradmotion.com` 上）
4. 生成token后，重定向到 `/auth/callback?token=xxx`（在 `login.gradmotion.com` 上）
5. `auth_callback.html` 保存token到 `login.gradmotion.com` 的 localStorage
6. 然后跳转到 `essay.gradmotion.com/?token=xxx`（通过URL参数传递token）
7. `essay.gradmotion.com` 页面加载，`user_menu.js` 执行

### 问题根源

**核心问题**：`checkAuthRequired()` 函数中的逻辑问题

在 `user_menu.js` 第39-97行的 `checkAuthRequired()` 函数中：

```javascript
async function checkAuthRequired() {
    // 如果是公开页面，不需要检测
    if (isPublicPage()) {
        return true;
    }
    
    // 先从URL参数中提取token（如果有）
    extractAndSaveTokenFromUrl();  // ← 这里提取并保存token
    
    const token = localStorage.getItem('auth_token');  // ← 但这里立即读取，可能还没保存完成
    
    if (!token) {
        // 跳转到登录页
        window.location.href = '/login';
        return false;
    }
    
    // 验证token...
}
```

**问题1**：`extractAndSaveTokenFromUrl()` 是同步函数，但 `localStorage.setItem()` 可能有延迟
**问题2**：即使token已保存，`checkAuthRequired()` 中的 `fetch('/api/auth/user-info')` 可能失败
**问题3**：如果API验证失败，会立即跳转到登录页，形成循环

### 具体问题点

1. **`extractAndSaveTokenFromUrl()` 在 `checkAuthRequired()` 内部调用**：
   - 虽然会保存token，但后续的 `localStorage.getItem()` 可能读取不到（时序问题）
   - 或者token保存成功，但API验证失败

2. **API验证失败时的处理**：
   - 如果 `/api/auth/user-info` 返回非200状态码，会立即跳转到登录页
   - 但可能只是网络延迟或临时错误，不应该立即跳转

3. **跨域问题**：
   - `essay.gradmotion.com` 和 `login.gradmotion.com` 的 localStorage 是隔离的
   - token通过URL参数传递，但提取和保存的时机可能有问题

## 修复方案

### 方案1：修复 `checkAuthRequired()` 逻辑（推荐）

**修复点1**：确保token提取和保存完成后再检查

```javascript
async function checkAuthRequired() {
    // 如果是公开页面，不需要检测
    if (isPublicPage()) {
        return true;
    }
    
    // ✅ 修复：先提取并保存token，确保完成后再读取
    const hasTokenInUrl = extractAndSaveTokenFromUrl();
    
    // ✅ 修复：如果从URL提取到token，等待一小段时间确保保存完成
    if (hasTokenInUrl) {
        await new Promise(resolve => setTimeout(resolve, 100)); // 等待100ms
    }
    
    const token = localStorage.getItem('auth_token');
    
    if (!token) {
        // 未登录，跳转到登录页
        console.log('未登录，跳转到登录页');
        localStorage.setItem('redirect_after_login', currentPath + window.location.search);
        if (window.location.hostname !== 'login.gradmotion.com') {
            localStorage.setItem('original_host', window.location.hostname);
        }
        window.location.href = '/login';
        return false;
    }
    
    // ✅ 修复：验证token时，增加重试机制和更详细的错误处理
    try {
        const response = await fetch('/api/auth/user-info', {
            headers: {
                'Authorization': `Bearer ${token}`
            },
            // ✅ 修复：增加超时设置
            signal: AbortSignal.timeout(5000) // 5秒超时
        });
        
        if (!response.ok) {
            // ✅ 修复：区分不同类型的错误
            if (response.status === 401) {
                // Token无效，清除并跳转登录
                console.log('Token无效（401），跳转到登录页');
                localStorage.removeItem('auth_token');
                localStorage.setItem('redirect_after_login', currentPath + window.location.search);
                if (window.location.hostname !== 'login.gradmotion.com') {
                    localStorage.setItem('original_host', window.location.hostname);
                }
                window.location.href = '/login';
                return false;
            } else {
                // ✅ 修复：其他错误（如500）不立即跳转，可能是服务器问题
                console.warn('Token验证失败，但可能是服务器问题，不跳转:', response.status);
                // 允许继续访问，但记录错误
                return true; // 允许访问，避免循环
            }
        }
        
        return true;
    } catch (error) {
        // ✅ 修复：网络错误时，不立即跳转，可能是临时网络问题
        if (error.name === 'AbortError' || error.name === 'TimeoutError') {
            console.warn('Token验证超时，可能是网络问题，允许继续访问');
            return true; // 允许访问，避免循环
        }
        
        console.error('验证登录失败:', error);
        // ✅ 修复：只有确认是认证错误时才跳转
        // 网络错误时允许继续访问，避免循环
        console.warn('网络错误，但不跳转，避免循环');
        return true; // 允许访问，避免循环
    }
}
```

### 方案2：优化 `extractAndSaveTokenFromUrl()` 函数

**修复点**：确保token保存是同步的，并返回保存结果

```javascript
function extractAndSaveTokenFromUrl() {
    const urlParams = new URLSearchParams(window.location.search);
    const token = urlParams.get('token');
    
    if (token) {
        console.log('✅ 从URL参数中提取到token，正在保存到当前域名:', window.location.hostname);
        
        // ✅ 修复：立即保存，确保同步完成
        try {
            localStorage.setItem('auth_token', token);
            console.log('✅ Token已保存到', window.location.hostname);
            
            // ✅ 修复：验证保存是否成功
            const savedToken = localStorage.getItem('auth_token');
            if (savedToken !== token) {
                console.error('❌ Token保存失败！');
                return false;
            }
            
            // 清除URL中的token参数（安全考虑）
            urlParams.delete('token');
            const cleanUrl = window.location.pathname + (urlParams.toString() ? '?' + urlParams.toString() : '');
            window.history.replaceState({}, '', cleanUrl);
            
            console.log('✅ Token已保存并清除URL参数');
            return true;
        } catch (e) {
            console.error('❌ 保存token失败:', e);
            return false;
        }
    }
    
    return false;
}
```

### 方案3：修复 `initAuth()` 执行顺序

**修复点**：确保token提取在检查之前完成

```javascript
(async function initAuth() {
    // ✅ 修复：首先从URL参数中提取token（必须在最前面）
    const hasTokenInUrl = extractAndSaveTokenFromUrl();
    
    if (hasTokenInUrl) {
        console.log('✅ 从URL参数中提取到token，已保存到当前域名的localStorage');
        // ✅ 修复：等待一小段时间确保保存完成
        await new Promise(resolve => setTimeout(resolve, 50));
    }
    
    // ✅ 修复：验证token是否已保存
    const token = localStorage.getItem('auth_token');
    if (!token && hasTokenInUrl) {
        console.error('❌ Token提取失败，但URL中有token参数');
        // 重试一次
        extractAndSaveTokenFromUrl();
        await new Promise(resolve => setTimeout(resolve, 50));
    }
    
    // 1. 先执行强制登录检测（这会阻止未登录用户访问）
    const isAuthenticated = await checkAuthRequired();
    
    // 2. 如果通过验证，等待DOM加载后更新导航栏按钮
    if (isAuthenticated) {
        // 等待DOM加载完成后再更新按钮（因为按钮元素可能还没渲染）
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', updateUserButton);
        } else {
            // DOM已加载，立即更新
            updateUserButton();
        }
    }
})();
```

## 完整修复代码

需要修改 `static/js/user_menu.js` 中的以下部分：

1. **`extractAndSaveTokenFromUrl()` 函数**：增加错误处理和验证
2. **`checkAuthRequired()` 函数**：优化错误处理，避免网络错误时立即跳转
3. **`initAuth()` 函数**：确保token提取和保存完成后再检查

## 测试验证

修复后，测试以下场景：

1. ✅ 在 `essay.gradmotion.com/login` 登录后，跳转到 `essay.gradmotion.com/` 应该正常
2. ✅ 点击"论文清单"跳转到其他页面，不应该跳回登录页
3. ✅ 刷新页面，应该保持登录状态
4. ✅ 在浏览器控制台检查token是否正确保存

## 临时解决方案

如果问题紧急，可以临时禁用某些页面的强制登录验证：

```javascript
// 在 user_menu.js 中，临时添加更多公开页面
const publicPages = ['/login', '/auth/callback', '/admin/login', '/test', '/', '/bilibili'];
```

**⚠️ 注意**：这只是临时方案，不应该长期使用。

