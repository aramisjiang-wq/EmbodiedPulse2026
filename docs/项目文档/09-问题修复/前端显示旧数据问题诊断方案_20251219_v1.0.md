# 前端显示旧数据问题诊断方案

## 问题描述

服务器数据库已更新（播放量171,419），但前端页面（https://essay.gradmotion.com/bilibili）仍显示旧数据（5530）。

## 完整数据流分析

### 数据流转路径

```
1. B站API
   ↓ (播放量: 171,419)
2. 数据库 (bilibili.db)
   ↓ (播放量: 171,419) ✅ 已确认更新
3. 后端API (/api/bilibili/all)
   ↓ (可能有缓存)
4. 前端JavaScript (loadBilibiliAll)
   ↓ (处理数据)
5. renderLatestVideos函数
   ↓ (渲染HTML)
6. 前端页面显示
```

### 各环节检查点

#### 环节1：数据库 ✅ 已确认
- **状态**: 已更新
- **播放量**: 171,419
- **验证命令**: 
  ```bash
  python3 -c "from bilibili_models import get_bilibili_session, BilibiliVideo; s=get_bilibili_session(); v=s.query(BilibiliVideo).filter_by(bvid='BV1L8qEBKEFW').first(); print(f'播放量: {v.play:,}') if v else print('未找到'); s.close()"
  ```

#### 环节2：后端API缓存 ⚠️ 可能问题
- **缓存机制**: 5分钟缓存（CACHE_DURATION = 300秒）
- **缓存位置**: `bilibili_cache['all_data']`
- **清除方法**: 
  - 方法1: 使用 `force=1` 参数: `/api/bilibili/all?force=1`
  - 方法2: 重启服务: `systemctl restart embodiedpulse`
  - 方法3: 等待5分钟自动过期

#### 环节3：前端API调用
- **API端点**: `/api/bilibili/all`
- **调用位置**: `templates/bilibili.html` 中的 `loadBilibiliAll()` 函数
- **数据格式**: `{success: true, data: [{user_info: {...}, videos: [...]}]}`

#### 环节4：前端数据处理
- **函数**: `renderLatestVideos(cards)`
- **数据来源**: `cards` 数组中的 `videos`
- **显示字段**: `video.play` (第1997行)
- **筛选逻辑**: 7天内的视频（第1974行）

#### 环节5：前端显示
- **HTML元素**: `class="latest-video-title"` 下的视频标题
- **播放量显示**: `class="latest-video-meta"` 中的 `<i class="fas fa-play"></i> ${videoPlay}`

## 问题诊断步骤

### 步骤1：检查后端API返回的数据

在服务器上运行：

```bash
cd /srv/EmbodiedPulse2026
source venv/bin/activate

# 方法1: 直接调用API（绕过缓存）
python3 << 'EOF'
import requests
import json

# 使用force=1清除缓存
url = 'http://localhost:5001/api/bilibili/all?force=1'
response = requests.get(url, timeout=10)
data = response.json()

if data.get('success'):
    cards = data.get('data', [])
    for card in cards:
        if card.get('user_info', {}).get('mid') == 1172054289:
            videos = card.get('videos', [])
            for video in videos:
                if '定义具身机器人通用基座' in video.get('title', '') and 'TRON 2 正式发布' in video.get('title', ''):
                    print(f"✅ 找到目标视频:")
                    print(f"BV号: {video.get('bvid')}")
                    print(f"标题: {video.get('title')}")
                    print(f"播放量(play): {video.get('play')}")
                    print(f"播放量(play_raw): {video.get('play_raw')}")
                    break
            break
else:
    print(f"❌ API返回失败: {data}")
EOF
```

### 步骤2：检查后端缓存状态

在服务器上运行：

```bash
python3 << 'EOF'
import sys
sys.path.insert(0, '/srv/EmbodiedPulse2026')

# 导入app模块检查缓存
import app
from datetime import datetime

with app.bilibili_cache_lock:
    cached_data = app.bilibili_cache.get('all_data')
    cache_expires_at = app.bilibili_cache.get('all_expires_at')
    
    if cached_data:
        print(f"✅ 缓存存在")
        print(f"过期时间: {datetime.fromtimestamp(cache_expires_at) if cache_expires_at else 'N/A'}")
        
        # 检查目标视频
        cards = cached_data.get('data', [])
        for card in cards:
            if card.get('user_info', {}).get('mid') == 1172054289:
                videos = card.get('videos', [])
                for video in videos:
                    if 'BV1L8qEBKEFW' == video.get('bvid'):
                        print(f"\n缓存中的视频数据:")
                        print(f"播放量(play): {video.get('play')}")
                        print(f"播放量(play_raw): {video.get('play_raw')}")
                        break
    else:
        print("❌ 缓存不存在")
EOF
```

### 步骤3：清除后端缓存

在服务器上运行：

```bash
# 方法1: 重启服务（会清除所有缓存）
systemctl restart embodiedpulse

# 方法2: 通过Python清除缓存
python3 << 'EOF'
import sys
sys.path.insert(0, '/srv/EmbodiedPulse2026')
import app

with app.bilibili_cache_lock:
    app.bilibili_cache['all_data'] = None
    app.bilibili_cache['all_expires_at'] = None
    print("✅ 缓存已清除")
EOF
```

### 步骤4：检查前端浏览器缓存

在浏览器中：
1. 打开开发者工具（F12）
2. 切换到 Network 标签
3. 勾选 "Disable cache"
4. 刷新页面
5. 查看 `/api/bilibili/all` 请求的响应

### 步骤5：检查前端JavaScript逻辑

在浏览器控制台运行：

```javascript
// 检查API返回的数据
fetch('/api/bilibili/all?force=1')
  .then(r => r.json())
  .then(data => {
    console.log('API返回数据:', data);
    const cards = data.data || [];
    const limxCard = cards.find(c => c.user_info?.mid === 1172054289);
    if (limxCard) {
      const video = limxCard.videos.find(v => v.bvid === 'BV1L8qEBKEFW');
      if (video) {
        console.log('目标视频数据:', video);
        console.log('播放量(play):', video.play);
        console.log('播放量(play_raw):', video.play_raw);
      }
    }
  });
```

## 可能的问题原因

### 问题1：后端API缓存未清除
- **症状**: 数据库已更新，但API返回旧数据
- **原因**: `bilibili_cache['all_data']` 缓存了旧数据
- **解决**: 使用 `force=1` 参数或重启服务

### 问题2：前端使用了错误的字段
- **症状**: API返回新数据，但前端显示旧数据
- **原因**: 前端使用 `video.play`（格式化值）而不是 `video.play_raw`（原始值）
- **检查**: 第1997行 `const videoPlay = escapeHtml(video.play || '0');`

### 问题3：前端浏览器缓存
- **症状**: 刷新后仍显示旧数据
- **原因**: 浏览器缓存了API响应
- **解决**: 强制刷新（Ctrl+F5）或清除浏览器缓存

### 问题4：数据格式问题
- **症状**: 数据存在但显示不正确
- **原因**: `video.play` 可能是格式化字符串（如"17.1万"）而不是数字
- **检查**: 确认API返回的 `play` 字段格式

## 解决方案

### 方案1：清除后端缓存（推荐）

```bash
# 在服务器上执行
cd /srv/EmbodiedPulse2026
source venv/bin/activate

# 清除缓存
python3 << 'EOF'
import sys
sys.path.insert(0, '/srv/EmbodiedPulse2026')
import app

with app.bilibili_cache_lock:
    app.bilibili_cache['all_data'] = None
    app.bilibili_cache['all_expires_at'] = None
    print("✅ 缓存已清除")
EOF

# 重启服务
systemctl restart embodiedpulse
```

### 方案2：修改前端使用force参数

修改 `templates/bilibili.html` 中的API调用：

```javascript
// 修改前
const response = await fetch('/api/bilibili/all');

// 修改后（添加时间戳避免缓存）
const response = await fetch(`/api/bilibili/all?force=1&_t=${Date.now()}`);
```

### 方案3：检查并修复数据格式

确保后端API返回的 `play` 字段是正确的格式化值：

```python
# 在 app.py 的 /api/bilibili/all 路由中
formatted_videos.append({
    'bvid': video.bvid,
    'title': video.title or '',
    'play': video.play_formatted or '0',  # 确保使用格式化值
    'play_raw': video.play or 0,          # 原始数值
    ...
})
```

## 诊断脚本

我已经创建了诊断脚本，在服务器上运行：

```bash
cd /srv/EmbodiedPulse2026
source venv/bin/activate
python3 scripts/diagnose_bilibili_cache.py
```

## 下一步行动

1. **立即执行**: 在服务器上清除缓存并重启服务
2. **验证**: 检查后端API返回的数据
3. **前端验证**: 在浏览器中检查API响应
4. **如果仍有问题**: 检查前端JavaScript逻辑

