# 服务器端B站播放量数据流完整梳理

## 服务器环境信息

- **服务器路径**: `/srv/EmbodiedPulse2026`
- **数据库**: SQLite (`sqlite:///./bilibili.db` → `/srv/EmbodiedPulse2026/bilibili.db`)
- **服务**: `embodiedpulse.service` (systemd)
- **Web服务器**: Gunicorn
- **前端访问**: `https://essay.gradmotion.com/bilibili`
- **管理端访问**: `https://admin123.gradmotion.com/admin/bilibili`

## 完整数据流链路

### 链路1: 用户端页面 (`/bilibili`)

```
数据库 (bilibili.db)
  ↓
BilibiliVideo.play (BigInteger) = 171,419
BilibiliVideo.play_formatted (String) = "5.5万" (可能过时)
  ↓
app.py: get_all_bilibili() 函数
  ↓
第1321行: 'play': video.play_formatted or '0'  ⚠️ 问题点1
第1322行: 'play_raw': video.play or 0  ✅ 正确
  ↓
API返回 JSON: /api/bilibili/all
{
  "play": "5.5万",  ⚠️ 旧值（来自play_formatted）
  "play_raw": 171419  ✅ 正确值
}
  ↓
前端模板: templates/bilibili.html
  ↓
renderLatestVideos() 函数 (第1959行)
  ↓
第1998行: const playRaw = video.play_raw || video.play || 0;
第1999行: const videoPlay = typeof playRaw === 'number' ? formatNumber(playRaw) : escapeHtml(video.play || '0');
  ↓
显示: 如果play_raw存在 → 17.1万 ✅
      如果play_raw不存在 → 5.5万 ❌
```

### 链路2: 管理端页面 (`/admin/bilibili`)

```
数据库 (bilibili.db)
  ↓
BilibiliVideo.play (BigInteger) = 171,419
BilibiliVideo.play_formatted (String) = "5.5万" (可能过时)
  ↓
auth_routes.py: get_bilibili_videos() 函数
  ↓
第2084行: video_dict = video.to_dict()
  ↓
bilibili_models.py: BilibiliVideo.to_dict() 方法
  ↓
第153行: 'play': self.play_formatted or '0'  ⚠️ 问题点2
第154行: 'play_raw': self.play  ✅ 正确
  ↓
API返回 JSON: /api/admin/bilibili/videos
{
  "play": "5.5万",  ⚠️ 旧值（来自play_formatted）
  "play_raw": 171419  ✅ 正确值
}
  ↓
前端JS: static/js/admin_bilibili.js
  ↓
displayVideos() 函数 (第285行)
  ↓
第298行: ${video.play_formatted || formatNumber(video.play || 0)}
  ↓
显示: play_formatted存在 → 5.5万 ❌
      如果play_formatted不存在 → formatNumber("5.5万") → 错误 ❌
```

## 问题根源分析

### 问题1: API层使用过时的play_formatted

**位置**: 
- `app.py` 第1321行
- `bilibili_models.py` 第153行

**问题**: 
- API返回的 `play` 字段使用 `play_formatted`（数据库字段，可能过时）
- 虽然 `play_raw` 是正确的，但前端可能优先使用 `play` 字段

### 问题2: 数据库play_formatted字段可能过时

**位置**: 数据库 `bilibili_videos` 表的 `play_formatted` 字段

**问题**: 
- 当 `play` 字段更新时，`play_formatted` 可能没有同步更新
- 导致API返回旧值

### 问题3: 前端fallback逻辑不完善

**位置**: 
- `templates/bilibili.html` 第1998-1999行
- `static/js/admin_bilibili.js` 第298行

**问题**: 
- 用户端：如果 `play_raw` 不存在，会使用 `play`（格式化字符串）
- 管理端：优先使用 `play_formatted`，如果不存在才使用 `play`

## 服务器端修复方案

### 修复点1: API层实时格式化（最重要）

**文件**: `app.py` 第1321行

**修改前**:
```python
'play': video.play_formatted or '0',
```

**修改后**:
```python
'play': format_number(video.play) if video.play else '0',  # 实时格式化，不依赖play_formatted
```

**影响**: 
- ✅ 用户端API `/api/bilibili/all` 返回正确的播放量
- ✅ 不依赖数据库中的 `play_formatted` 字段

### 修复点2: 模型层实时格式化

**文件**: `bilibili_models.py` 第153行

**修改前**:
```python
'play': self.play_formatted or '0',
```

**修改后**:
```python
'play': format_number(self.play) if self.play else '0',  # 实时格式化
```

**需要添加import**:
```python
from bilibili_client import format_number
```

**影响**: 
- ✅ 管理端API `/api/admin/bilibili/videos` 返回正确的播放量
- ✅ 所有使用 `to_dict()` 的地方都会返回正确值

### 修复点3: 更新数据库play_formatted字段（可选）

**目的**: 保持数据一致性

**方法**: 运行更新脚本
```bash
python3 scripts/update_play_formatted.py
```

## 服务器端完整修复命令

```bash
cd /srv/EmbodiedPulse2026
source venv/bin/activate

echo "=========================================="
echo "服务器端B站播放量数据流修复"
echo "=========================================="
echo ""

echo "【1. 检查当前数据库数据】"
python3 << 'PYEOF'
from bilibili_models import get_bilibili_session, BilibiliVideo
session = get_bilibili_session()
video = session.query(BilibiliVideo).filter_by(bvid='BV1L8qEBKEFW').first()
if video:
    print(f"数据库实际数据:")
    print(f"  play (原始数字): {video.play:,}")
    print(f"  play_formatted (格式化字符串): {video.play_formatted}")
    print(f"  更新时间: {video.updated_at}")
else:
    print("❌ 未找到视频")
session.close()
PYEOF

echo ""
echo "【2. 检查当前API返回（修复前）】"
python3 << 'PYEOF'
from app import app
with app.test_client() as client:
    response = client.get('/api/bilibili/all?force=1')
    data = response.get_json()
    if data and data.get('success'):
        cards = data.get('data', [])
        for card in cards:
            if card.get('user_info', {}).get('mid') == 1172054289:
                videos = card.get('videos', [])
                if videos:
                    latest = videos[0]
                    print(f"API当前返回:")
                    print(f"  play: {latest.get('play')}")
                    print(f"  play_raw: {latest.get('play_raw')}")
                    break
PYEOF

echo ""
echo "【3. 备份文件】"
cp app.py app.py.backup.$(date +%Y%m%d_%H%M%S)
cp bilibili_models.py bilibili_models.py.backup.$(date +%Y%m%d_%H%M%S)
echo "✅ 备份完成"

echo ""
echo "【4. 修复 app.py】"
python3 << 'PYEOF'
import re

with open('app.py', 'r', encoding='utf-8') as f:
    content = f.read()

# 检查是否已修复
if 'format_number(video.play)' in content:
    print("✅ app.py 已修复")
else:
    # 查找并替换
    old_pattern = r"'play':\s*video\.play_formatted\s+or\s+'0'"
    new_pattern = "'play': format_number(video.play) if video.play else '0'"
    
    if re.search(old_pattern, content):
        content = re.sub(old_pattern, new_pattern, content)
        with open('app.py', 'w', encoding='utf-8') as f:
            f.write(content)
        print("✅ app.py 已修复")
    else:
        print("⚠️  未找到匹配代码，显示相关代码:")
        lines = content.split('\n')
        for i, line in enumerate(lines, 1):
            if i >= 1315 and i <= 1330 and 'play' in line:
                print(f"   第{i}行: {line.strip()}")
PYEOF

echo ""
echo "【5. 修复 bilibili_models.py】"
python3 << 'PYEOF'
import re

with open('bilibili_models.py', 'r', encoding='utf-8') as f:
    content = f.read()

# 检查是否已修复
if 'format_number(self.play)' in content:
    print("✅ bilibili_models.py 已修复")
else:
    # 添加import
    if 'from bilibili_client import format_number' not in content:
        # 查找import区域
        import_match = re.search(r'(from bilibili_client import[^\n]+)', content)
        if import_match:
            # 如果已有import，添加到那一行
            old_import = import_match.group(1)
            if 'format_number' not in old_import:
                content = content.replace(old_import, old_import + ', format_number')
        else:
            # 在文件开头添加import
            lines = content.split('\n')
            for i, line in enumerate(lines):
                if 'from sqlalchemy' in line or ('import' in line and i < 20):
                    lines.insert(i+1, 'from bilibili_client import format_number')
                    break
            content = '\n'.join(lines)
    
    # 替换play字段
    old_pattern = r"'play':\s*self\.play_formatted\s+or\s+'0'"
    new_pattern = "'play': format_number(self.play) if self.play else '0'"
    
    if re.search(old_pattern, content):
        content = re.sub(old_pattern, new_pattern, content)
        with open('bilibili_models.py', 'w', encoding='utf-8') as f:
            f.write(content)
        print("✅ bilibili_models.py 已修复")
    else:
        print("⚠️  未找到匹配代码，显示相关代码:")
        lines = content.split('\n')
        for i, line in enumerate(lines, 1):
            if i >= 150 and i <= 160 and 'play' in line:
                print(f"   第{i}行: {line.strip()}")
PYEOF

echo ""
echo "【6. 验证修复】"
echo "检查 app.py:"
grep -n "format_number(video.play)" app.py | head -1 || echo "❌ 未修复"

echo "检查 bilibili_models.py:"
grep -n "format_number(self.play)" bilibili_models.py | head -1 || echo "❌ 未修复"

echo ""
echo "【7. 清除缓存】"
python3 << 'EOF'
import sys
sys.path.insert(0, '/srv/EmbodiedPulse2026')
import app
with app.bilibili_cache_lock:
    app.bilibili_cache['all_data'] = None
    app.bilibili_cache['all_expires_at'] = None
    app.bilibili_cache['data'] = None
    app.bilibili_cache['expires_at'] = None
print("✅ 缓存已清除")
EOF

echo ""
echo "【8. 重启服务】"
systemctl restart embodiedpulse
sleep 3
systemctl status embodiedpulse --no-pager -l | head -10

echo ""
echo "【9. 测试修复后的API】"
python3 << 'PYEOF'
from app import app
with app.test_client() as client:
    response = client.get('/api/bilibili/all?force=1')
    data = response.get_json()
    if data and data.get('success'):
        cards = data.get('data', [])
        for card in cards:
            if card.get('user_info', {}).get('mid') == 1172054289:
                videos = card.get('videos', [])
                if videos:
                    latest = videos[0]
                    print(f"✅ 修复后API返回:")
                    print(f"  play: {latest.get('play')}")
                    print(f"  play_raw: {latest.get('play_raw')}")
                    if latest.get('play_raw') == 171419:
                        print("✅ 数据正确！")
                    break
PYEOF

echo ""
echo "【10. 测试管理端API】"
python3 << 'PYEOF'
from bilibili_models import get_bilibili_session, BilibiliVideo
session = get_bilibili_session()
video = session.query(BilibiliVideo).filter_by(bvid='BV1L8qEBKEFW').first()
if video:
    video_dict = video.to_dict()
    print(f"✅ to_dict()返回:")
    print(f"  play: {video_dict.get('play')}")
    print(f"  play_raw: {video_dict.get('play_raw')}")
session.close()
PYEOF

echo ""
echo "=========================================="
echo "修复完成！"
echo "=========================================="
echo ""
echo "请访问以下页面验证："
echo "1. https://essay.gradmotion.com/bilibili"
echo "2. https://admin123.gradmotion.com/admin/bilibili"
echo ""
echo "如果仍显示旧值："
echo "1. 强制刷新浏览器：Ctrl+Shift+R"
echo "2. 清除浏览器缓存"
echo "3. 检查浏览器控制台 Network 标签"
```

## 数据流修复前后对比

### 修复前

```
数据库 play=171419, play_formatted="5.5万"
  ↓
API返回 play="5.5万", play_raw=171419
  ↓
前端显示 "5.5万" ❌
```

### 修复后

```
数据库 play=171419, play_formatted="5.5万" (不影响)
  ↓
API返回 play="17.1万" (实时格式化), play_raw=171419
  ↓
前端显示 "17.1万" ✅
```

## 关键点

1. **服务器端代码**: 所有修改都在 `/srv/EmbodiedPulse2026/` 目录
2. **数据库**: SQLite文件在 `/srv/EmbodiedPulse2026/bilibili.db`
3. **服务重启**: 必须重启 `embodiedpulse.service` 才能生效
4. **缓存清除**: 清除内存中的缓存，确保获取最新数据
5. **浏览器缓存**: 前端可能缓存了旧数据，需要强制刷新

